package Lab1;

import java.util.Arrays;

public class GLIBC {
    private int MAX;
    private int seed;

    /**
     * @param MAX  elements in output string.
     * @param seed An seed used to generator. It is used to distinguish outputs.
     * @throws Exception
     */
    public GLIBC(int MAX, int seed) throws Exception {
        if (MAX < 0) throw new Exception("String of negative length cannot be generated.");
        if (seed < 0) throw new Exception("String of negative seed cannot be generated.");

        this.MAX = MAX;
        this.seed = seed;
    }

    /**
     * @return Generated string.
     */
    public String generateString() {
//            2^31 = 2147483647 - 1
        int modulo = 2147483647;
        int multiplier = 16807;
        int firstBound = 31;
        int secondBound = 34;
        int thirdBound = 344;

        StringBuilder output = new StringBuilder();
        int[] r = new int[this.MAX];

        r[0] = this.seed;
        for (int i = 1; i < firstBound; i++) {
            r[i] = (multiplier * r[i - 1]) % modulo;
            if (r[i] < 0) {
                r[i] += modulo;
            }
        }
        for (int i = firstBound; i < secondBound; i++) {
            r[i] = r[i - firstBound];
        }
        for (int i = secondBound; i < thirdBound; i++) {
            r[i] = r[i - firstBound] + r[i - 3];
        }

        for (int i = thirdBound; i < this.MAX; i++) {
            r[i] = r[i - firstBound] + r[i - 3];
            output.append(r[i] >> 1);
            output.append("_");
        }
        return output.toString();
    }


    private static boolean areZeros(String str, int index) {
        int[] numbers = Arrays.stream(str.split("_")).mapToInt(Integer::parseInt).toArray();

        int iter = index;
        while (iter < numbers.length) {
            if (numbers[iter] != 0)
                return false;
            iter++;
        }
        return true;
    }

    public static boolean isGLIBC(String str, SolutionClass sC) throws Exception {
        switch (sC) {
            case Cycle:
                return GLIBC.isGLIBC1(str);
            case Equation:
                return GLIBC.isGLIBC2(str);
            default:
                return false;
        }
    }

    /**
     * Following methods looks for a cycle in the string.
     * It can be proved, than to any cycle can be assigned at least one set of arguments to the Lab1.LCG generator,
     * used to generate such string.
     * What about if string is too short to loop itself?
     * We can resolve an equations set to check if it's generated by Lab1.LCG, but it's too difficult.
     * When c==0, string can get at some point 0, and then is looped by 0's.
     *
     * @param str String to be checked. Elements of an array must be separated by '_' sign.
     * @return True if given string is generated by the Lab1.LCG.
     * @throws Exception if string is empty.
     */
    private static boolean isGLIBC1(String str) throws Exception {
        int[] numbers = Arrays.stream(str.split("_")).mapToInt(Integer::parseInt).toArray();
        int size = numbers.length;

        if (size == 0) throw new Exception("Given string is too short!");

        for (int sizeOfWindow = 1; sizeOfWindow < size; sizeOfWindow++) {
            int[] window = new int[sizeOfWindow];
            boolean isWindowCycle = true;

//            copy elements from beginning of the array to the window.
            System.arraycopy(numbers, 0, window, 0, sizeOfWindow);

            int windowIterator = 0;
            while (isWindowCycle) {
                for (int glass = 0; glass < sizeOfWindow; glass++) {
                    int indexInString = windowIterator * sizeOfWindow + glass;
                    if (indexInString >= size) {
                        return true;
                    }
                    if (numbers[indexInString] != window[glass]) {
                        if (numbers[indexInString] == 0 && areZeros(str, indexInString))
                            return true;
                        isWindowCycle = false;
                        break;
                    }
                }
                windowIterator++;
            }
        }
        return false;
    }

    /**
     * This solution tried to find a tuple of variables: (x0, a, c, modulo) for given string.
     * Three first elements of the input string are enough. After that we check the rest of the string.
     * To find such solution, we have to solve a set of equations.
     *
     * @param str String to be checked. Elements of an array must be separated by '_' sign.
     * @return True if given string is generated by the Lab1.LCG.
     * @throws Exception if string is empty.
     */
    private static boolean isGLIBC2(String str) throws Exception {
        if (str.length() <= 3)
            throw new Exception("Given string is too short!");
        int[] numbers = Arrays.stream(str.split("_")).mapToInt(Integer::parseInt).toArray();

//        final int MAX = 1000;
        int MAX = -1;
        for (int num : numbers) {
            if (num > MAX) MAX = num;
        }
        int i = 0, j = 0, k = 0, iterator = 0;

        EquationClass eqClass = EquationClass.CONTRADICTORY;

//        [ a, c, m ]
        int[][] eqSolution = new int[MAX][3];
        int eqIterator = 0;

        int[] y = {numbers[0], numbers[1], numbers[2]};
        int[] w = {numbers[1], numbers[2], numbers[3]};

        while (iterator < MAX) {
            while (i < MAX) {
                while (j < MAX) {
                    while (k < MAX) {

                        int la = (-y[0] + y[1]) * (i - k) - (-y[0] + y[2]) * (i - j);
                        int ma = (w[0] + w[1]) * (i - k) - (w[0] - w[2]) * (i - j);

                        if (la == 0 && ma == 0) eqClass = EquationClass.IDENTITY;
                        else if (la == 0 && ma != 0) eqClass = EquationClass.CONTRADICTORY;
                        else if (!((la < 0 && ma < 0) || (la > 0 && ma > 0))) eqClass = EquationClass.CONTRADICTORY;
                        else if (la / ma * ma != la) eqClass = EquationClass.CONTRADICTORY;
                        else {
                            int a = la / ma;
                            int lm = w[1] - w[0] + y[0] * a - y[1] * a;
                            int mm = i - j;

                            if (lm == 0 && mm == 0) eqClass = EquationClass.IDENTITY;
                            else if (lm == 0 && mm != 0) eqClass = EquationClass.CONTRADICTORY;
                            else if (!((lm < 0 && mm < 0) || (lm > 0 && mm > 0))) eqClass = EquationClass.CONTRADICTORY;
                            else if (lm / mm * mm != lm) eqClass = EquationClass.CONTRADICTORY;
                            else {
                                int m = lm / mm;
                                int c = w[0] - y[0] + i * m;

                                if ((0 >= a || a >= m) || (0 > c || c >= m)) eqClass = EquationClass.CONTRADICTORY;
                                else {
//                                        [ a, c, m ]
                                    eqSolution[eqIterator][0] = a;
                                    eqSolution[eqIterator][0] = c;
                                    eqSolution[eqIterator][0] = m;
                                    eqClass = EquationClass.CORRECT;

                                    for (int l = 1; l < numbers.length; l++) {
                                        if (numbers[l] != (a * numbers[l - 1] + c) % m) {
                                            throw new Exception("Solution doesn't match next elements!");
                                        }
                                    }

                                    eqIterator++;
                                }
                            }
                        }
                        if (eqClass == EquationClass.CORRECT)
                            break;
                        k++;
                    }
                    if (eqClass == EquationClass.CORRECT)
                        break;
                    j++;
                }
                if (eqClass == EquationClass.CORRECT)
                    break;
                i++;
            }
            if (eqClass == EquationClass.CORRECT)
                break;
            iterator++;
        }
        return (eqClass == EquationClass.CORRECT);
    }

}