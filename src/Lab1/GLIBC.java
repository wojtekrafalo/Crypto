package Lab1;

import java.util.Arrays;

public class GLIBC {
    private int MAX;
    private int seed;

    /**
     * @param MAX  elements in output string.
     * @param seed An seed used to generator. It is used to distinguish outputs.
     * @throws Exception When arguments are negative.
     */
    public GLIBC(int MAX, int seed) throws Exception {
        if (MAX < 0) throw new Exception("String of negative length cannot be generated.");
        if (seed < 0) throw new Exception("String of negative seed cannot be generated.");

        this.MAX = MAX;
        this.seed = seed;
    }

    /**
     * @return String generated by the GLIBC's random method.
     */
    public String generateString() {
//            2^31 = 2147483647 - 1
        int modulo = 2147483647;
        int multiplier = 16807;
        int firstBound = 31;
        int secondBound = 34;
        int thirdBound = 344;

        StringBuilder output = new StringBuilder();
        int[] r = new int[this.MAX];

        r[0] = this.seed;
        for (int i = 1; i < firstBound; i++) {
            r[i] = (multiplier * r[i - 1]) % modulo;
            if (r[i] < 0) {
                r[i] += modulo;
            }
        }
//        for (int i = firstBound; i < secondBound; i++) {
//            r[i] = r[i - firstBound];
//        }
        System.arraycopy(r, 0, r, firstBound, secondBound - firstBound);
        
        for (int i = secondBound; i < thirdBound; i++) {
            r[i] = r[i - firstBound] + r[i - 3];
        }

        for (int i = thirdBound; i < this.MAX; i++) {
            r[i] = r[i - firstBound] + r[i - 3];
            output.append(r[i] >> 1);
            output.append("_");
        }
        return output.toString();
    }


    private static boolean areZeros(String str, int index) {
        int[] numbers = Arrays.stream(str.split("_")).mapToInt(Integer::parseInt).toArray();

        int iter = index;
        while (iter < numbers.length) {
            if (numbers[iter] != 0)
                return false;
            iter++;
        }
        return true;
    }

    public static boolean isGLIBC(String str, SolutionClass sC) throws Exception {
        switch (sC) {
            case Cycle:
                return GLIBC.isGLIBC1(str);
            case Equation:
                return GLIBC.isGLIBC1(str);
            default:
                return false;
        }
    }

    /**
     * Following methods looks for a cycle in the string.
     * It can be proved, than to any cycle can be assigned at least one set of arguments to the Lab1.LCG generator,
     * used to generate such string.
     * What about if string is too short to loop itself?
     * We can resolve an equations set to check if it's generated by Lab1.LCG, but it's too difficult.
     * When c==0, string can get at some point 0, and then is looped by 0's.
     *
     * @param str String to be checked. Elements of an array must be separated by '_' sign.
     * @return True if given string is generated by the Lab1.LCG.
     * @throws Exception if string is empty.
     */
    private static boolean isGLIBC1(String str) throws Exception {
        int[] numbers = Arrays.stream(str.split("_")).mapToInt(Integer::parseInt).toArray();
        int size = numbers.length;

        if (size == 0) throw new Exception("Given string is too short!");

        for (int sizeOfWindow = 1; sizeOfWindow < size; sizeOfWindow++) {
            int[] window = new int[sizeOfWindow];
            boolean isWindowCycle = true;

//            copy elements from beginning of the array to the window.
            System.arraycopy(numbers, 0, window, 0, sizeOfWindow);

            int windowIterator = 0;
            while (isWindowCycle) {
                for (int glass = 0; glass < sizeOfWindow; glass++) {
                    int indexInString = windowIterator * sizeOfWindow + glass;
                    if (indexInString >= size) {
                        return true;
                    }
                    if (numbers[indexInString] != window[glass]) {
                        if (numbers[indexInString] == 0 && areZeros(str, indexInString))
                            return true;
                        isWindowCycle = false;
                        break;
                    }
                }
                windowIterator++;
            }
        }
        return false;
    }


}